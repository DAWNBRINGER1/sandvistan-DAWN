<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SANDEVISTAN</title>
    <link href="https://fonts.googleapis.com/css2?family=Aldrich&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script> 
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0; 
            overflow-x: hidden; 
            overflow-y: auto; 
            background-color: #000; 
            color: #e0e0e0; 
        }
        #scene-container {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw; 
            height: 100vh;
            z-index: 0;
        }
        .overlay-content {
            position: relative; 
            z-index: 10;
            display: flex;
            flex-direction: column;
            min-height: 100vh; 
            padding: 1rem; 
        }
        .overlay-content > * {
            pointer-events: auto; 
        }
        .title-glow {
            font-family: 'Aldrich', sans-serif; 
            color: #00ffff; 
            text-shadow: 0 0 8px #00ffff, 0 0 16px #00ffff, 0 0 24px #00ffff, 0 0 32px #00b8b8; 
            min-height: 1.2em; 
            cursor: pointer; 
            transition: text-shadow 0.3s ease;
            position: relative; /* Needed for glitch pseudo-elements */
        }
        .title-glow:hover {
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #ff00ff, 0 0 40px #ff00ff; 
        }
        
        /* Glitch Effect Styles */
        .glitch-active {
            /* animation: glitch-main 2.5s infinite steps(1); */ 
        }

        .glitch-active > span::before,
        .glitch-active > span::after {
            content: attr(data-text); 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000; 
            overflow: hidden;
        }

        .glitch-active > span::before {
            left: 2px;
            text-shadow: -2px 0 #ff00ff; 
            animation: glitch-before 1.5s infinite linear alternate-reverse; 
            clip-path: polygon(0 0, 100% 0, 100% 33%, 0 33%);
        }

        .glitch-active > span::after {
            left: -2px;
            text-shadow: -2px 0 #00ff00, 2px 2px #ff00ff; 
            animation: glitch-after 1.5s infinite linear alternate-reverse;  
            clip-path: polygon(0 67%, 100% 67%, 100% 100%, 0 100%);
        }

        @keyframes glitch-before {
            0% { clip-path: polygon(0 0, 100% 0, 100% 33%, 0 33%); transform: translateY(-2px); }
            10% { clip-path: polygon(0 25%, 100% 25%, 100% 55%, 0 55%); transform: translateY(1px); }
            20% { clip-path: polygon(0 60%, 100% 60%, 100% 80%, 0 80%); transform: translateY(-1px); }
            100% { clip-path: polygon(0 50%, 100% 50%, 100% 70%, 0 70%); transform: translateY(0); }
        }

        @keyframes glitch-after {
            0% { clip-path: polygon(0 67%, 100% 67%, 100% 100%, 0 100%); transform: translateY(1px); }
            10% { clip-path: polygon(0 40%, 100% 40%, 100% 70%, 0 70%); transform: translateY(-2px); }
            100% { clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%); transform: translateY(0); } 
        }


        .intro-text {
            font-family: 'Courier New', Courier, monospace;
            color: #00ffaa; 
            text-shadow: 0 0 5px #00ffaa;
            font-size: 1rem; 
            text-align: center;
            margin-top: 0.5rem; 
            margin-bottom: 1.5rem; 
            min-height: 1.5em; 
            line-height: 1.4;
            white-space: pre-wrap; 
            transition: opacity 0.7s ease-out; 
        }
        .intro-text.fading-out {
            opacity: 0;
        }


        .cyber-button {
            background-color: rgba(0, 255, 255, 0.1); 
            color: #00ffff; 
            border: 1px solid #00ffff; 
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem; 
            font-weight: 500; 
            text-transform: uppercase;
            letter-spacing: 0.075em; 
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.2); 
            transition: background-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease, border-color 0.3s ease, transform 0.1s ease;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace; 
            display: inline-flex; 
            align-items: center;
            justify-content: center; 
            min-height: 2.75rem; 
            margin-bottom: 0.5rem; 
        }

        .cyber-button:hover {
            background-color: rgba(0, 255, 255, 0.2); 
            color: #fff;
            border-color: #ff00ff; 
            box-shadow: 0 0 15px #00ffff, 0 0 25px rgba(0, 255, 255, 0.4), 0 0 8px #ff00ff; 
        }

        .cyber-button:active {
            transform: translateY(1px) scale(0.98);
            background-color: rgba(0, 255, 255, 0.3);
        }

        .cyber-button:disabled {
            background-color: rgba(0, 120, 120, 0.2); 
            color: #007777;
            border-color: #007777;
            box-shadow: none;
            cursor: not-allowed;
        }
        
        .blinking-cursor {
            display: inline-block;
            width: 8px; 
            height: 1.2em; 
            background-color: #00ffff; 
            animation: blink 1s step-end infinite;
            margin-left: 0.3em; 
            box-shadow: 0 0 3px #00ffff;
        }
         .blinking-cursor.hidden-cursor { 
            visibility: hidden;
        }


        @keyframes blink {
            from, to { background-color: transparent; box-shadow: none; }
            50% { background-color: #00ffff; box-shadow: 0 0 3px #00ffff; }
        }

        .button-text-prefix { 
            margin-right: 0.1em;
        }
        .button-container { 
            display: flex;
            flex-direction: column; 
            align-items: center; 
            gap: 0.5rem; 
            margin-bottom: 1rem; 
        }

        .cyber-input {
            background-color: rgba(10, 25, 47, 0.8); 
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem; 
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
            transition: box-shadow 0.3s ease, border-color 0.3s ease;
            font-family: 'Courier New', Courier, monospace;
        }
        .cyber-input:focus {
            outline: none;
            border-color: #ff00ff; 
            box-shadow: 0 0 12px rgba(255, 0, 255, 0.5);
        }
        .cyber-input::placeholder {
            color: rgba(0, 255, 255, 0.5);
        }
        .response-area {
            background-color: rgba(10, 20, 35, 0.7);
            border: 1px solid #007777; 
            color: #c0f0f0; 
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
            min-height: 100px;
            overflow-y: auto;
            max-height: 70vh; 
            box-shadow: inset 0 0 10px rgba(0, 120, 120, 0.3);
            font-family: 'Courier New', Courier, monospace;
            text-align: left; 
        }
        .response-area h2 {
            color: #00ffff;
            font-size: 1.25em;
            margin-top: 1em;
            margin-bottom: 0.5em;
            text-shadow: 0 0 3px #00ffff;
            font-family: 'Aldrich', sans-serif; 
        }
        .response-area h3 {
            color: #00dddd;
            font-size: 1.1em;
            margin-top: 0.8em;
            margin-bottom: 0.4em;
            text-shadow: 0 0 2px #00dddd;
            font-family: 'Aldrich', sans-serif; 
        }
        .response-area ul {
            list-style-type: none; 
            padding-left: 1em;
            margin-bottom: 0.7em;
        }
        .response-area li {
            margin-bottom: 0.3em;
            padding-left: 1.2em;
            position: relative;
        }
        .response-area li::before { 
            content: '>'; 
            position: absolute;
            left: 0;
            color: #00ffff;
        }
        .response-area p {
            margin-bottom: 0.7em;
            line-height: 1.5;
            white-space: pre-wrap; 
        }
        .response-area strong {
            color: #ffffff;
            font-weight: 600;
        }
        .response-area em { 
            color: #ff00ff; 
            font-style: normal; 
        }
        .response-area a {
            color: #00ffaa;
            text-decoration: underline;
            transition: color 0.3s ease;
        }
        .response-area a:hover {
            color: #ff00ff;
        }
        .response-area pre {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid #007777;
            padding: 0.75em;
            border-radius: 0.25rem;
            overflow-x: auto; 
            margin-top: 0.5em;
            margin-bottom: 1em;
            font-size: 0.9em;
            white-space: pre; 
        }
        .response-area code { 
            font-family: 'Courier New', Courier, monospace;
            color: #c0f0f0;
            background-color: rgba(0,20,30,0.5); 
            padding: 0.1em 0.3em;
            border-radius: 0.2em;
        }
        .response-area pre code { 
             padding: 0;
             background-color: transparent;
        }
        .response-area hr {
            border: 0;
            height: 1px;
            background-image: linear-gradient(to right, rgba(0, 255, 255, 0), rgba(0, 255, 255, 0.75), rgba(0, 255, 255, 0));
            margin-top: 1em;
            margin-bottom: 1em;
        }
        .loading-message {
            color: #ff00ff; 
            text-shadow: 0 0 5px #ff00ff;
            font-family: 'Courier New', Courier, monospace;
        }
        /* Mute Button Icon Styles */
        #mute-button {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background-color: rgba(0, 255, 255, 0.2);
            color: #00ffff; /* SVG will inherit this */
            border: 1px solid #00ffff;
            padding: 0.5rem; /* Adjusted for icon */
            width: 2.5rem; /* Make it squarish */
            height: 2.5rem;
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            z-index: 100; 
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
        }
        #mute-button:hover {
            background-color: rgba(0, 255, 255, 0.4);
            color: #ffffff;
            box-shadow: 0 0 8px #00ffff;
        }
        #mute-button svg {
            width: 1.5rem; /* 24px */
            height: 1.5rem; /* 24px */
        }
    </style>
</head>
<body class="bg-black text-white">

    <div id="scene-container"></div>

    <div class="overlay-content flex flex-col justify-between min-h-screen p-4 sm:p-6 md:p-8">
        <header class="w-full flex flex-col justify-center items-center mb-6 md:mb-8">
            <h1 id="website-title" class="text-4xl sm:text-5xl md:text-7xl font-thin tracking-widest text-center title-glow">
                <span id="website-title-typed-text" data-text="SANDEVISTAN"></span> </h1>
            <p id="intro-text-element" class="intro-text"></p> 
        </header>

        <main class="flex-grow w-full max-w-3xl mx-auto flex flex-col items-center">
            <button id="access-core-button" class="cyber-button mb-4 text-sm sm:text-base" style="visibility: hidden;"> 
                <span class="button-text-prefix">> </span><span id="access-core-button-typed-text"></span><span class="blinking-cursor"></span>
            </button>

            <div id="interaction-elements-container" class="w-full text-center" style="display: none;">
                <div class="w-full mb-4">
                    <textarea id="prompt-input" class="cyber-input w-full text-sm sm:text-base" rows="3" placeholder="> Ask about ethical hacking tools, cyberpunk lore, or paste a transmission to decode..."></textarea>
                </div>
                <div class="button-container"> 
                    <button id="send-query-button" class="cyber-button text-sm sm:text-base">
                         <span class="button-text-prefix">> </span><span id="send-query-button-typed-text"></span><span class="blinking-cursor"></span>
                    </button>
                     <button id="decode-transmission-button" class="cyber-button text-sm sm:text-base"> <span class="button-text-prefix">> </span><span id="decode-transmission-button-typed-text"></span><span class="blinking-cursor"></span>
                   </button>
                    <button id="system-status-button" class="cyber-button text-sm sm:text-base">
                        <span class="button-text-prefix">> </span><span id="system-status-button-typed-text"></span><span class="blinking-cursor"></span>
                   </button>
                   <button id="datascape-glimpse-button" class="cyber-button text-sm sm:text-base"> 
                        <span class="button-text-prefix">> </span><span id="datascape-glimpse-button-typed-text"></span><span class="blinking-cursor"></span>
                   </button>
                </div>
                <div id="loading-indicator" class="loading-message my-4" style="display: none;">
                    Accessing SANDEVISTAN databanks... Please wait...
                </div>
                <div id="response-output" class="response-area w-full text-sm text-left">
                    Awaiting transmission...
                </div>
            </div>
        </main>

        <footer class="w-full p-4 text-center text-xs text-gray-400 md:text-sm mt-8">
            <p>Wired into the neon stream. Knowledge is power.</p> 
        </footer>
    </div>
    
    <button id="mute-button" title="Toggle Background Music"> <svg id="unmute-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
            <path d="M0 0h24v24H0z" fill="none"/>
        </svg>
        <svg id="mute-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="display: none;">
            <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L7 9H3v6h4l5 5v-6.73l-5-5V4z"/>
            <path d="M0 0h24v24H0z" fill="none"/>
        </svg>
    </button>


    <script type="module">
        let scene, camera, renderer;
        const sceneContainer = document.getElementById('scene-container');
        let clock; 
        let hyperLinesGroup; 
        const NUM_HYPER_LINES = 200; 
        let starfieldPoints; 
        const NUM_STARFIELD_PARTICLES = 500; 
        let introDisintegrationParticles = []; 

        let bgmSynth;
        let bgmLoop;
        let isMuted = false;
        let audioStarted = false; 

        function setupBGM() {
            bgmSynth = new Tone.MonoSynth({
                oscillator: { type: "sine" }, 
                envelope: { attack: 2, decay: 1, sustain: 0.8, release: 3 },
                filterEnvelope: { attack: 1, decay: 0.5, sustain: 0.5, release: 2, baseFrequency: 200, octaves: 3 },
                volume: -25 
            }).toDestination();

            const notes = ["C2", "G2", "Eb2", "Bb1"]; 
            let noteIndex = 0;

            bgmLoop = new Tone.Loop(time => {
                bgmSynth.triggerAttackRelease(notes[noteIndex % notes.length], "8n", time); 
                noteIndex++;
            }, "2n"); 

            Tone.Transport.bpm.value = 60; 
        }

        function startBGM() {
            if (Tone.context.state !== 'running') {
                Tone.start(); 
            }
            if (bgmLoop && !bgmLoop.state === "started") {
                Tone.Transport.start();
                bgmLoop.start(0);
            } else if (bgmLoop && Tone.Transport.state !== "started") {
                 Tone.Transport.start();
                 bgmLoop.start(0); 
            }
            audioStarted = true; 
        }
        
        function createHyperLines() {
            hyperLinesGroup = new THREE.Group();
            const originYBase = 2.2; 
            const originZStart = -30; 
            const forwardEndPointZ = camera.position.z + 10;

            for (let i = 0; i < NUM_HYPER_LINES; i++) {
                const streakLength = 0.4 + Math.random() * 0.8; 
                const geometry = new THREE.BufferGeometry();
                const points = new Float32Array([0, 0, 0, 0, 0, -streakLength]); 
                geometry.setAttribute('position', new THREE.BufferAttribute(points, 3));
                
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.2 + Math.random() * 0.5 
                });
                
                const line = new THREE.Line(geometry, material);

                line.userData = {
                    origin: new THREE.Vector3(
                        (Math.random() - 0.5) * 1.5,      
                        originYBase + (Math.random() - 0.5) * 0.3, 
                        originZStart - Math.random() * 10  
                    ),
                    velocity: new THREE.Vector3(),
                    movingForward: true,
                    speed: 0.15 + Math.random() * 0.20
                };
                line.position.copy(line.userData.origin);

                const targetX = (Math.random() - 0.5) * 30; 
                const targetY = (Math.random() - 0.5) * 30;
                line.userData.velocity.subVectors(new THREE.Vector3(targetX, targetY, forwardEndPointZ), line.position)
                    .normalize()
                    .multiplyScalar(line.userData.speed); 

                line.lookAt(line.position.clone().add(line.userData.velocity)); 
                
                hyperLinesGroup.add(line);
            }
            scene.add(hyperLinesGroup);
        }

        function createStarfield() {
            const particles = NUM_STARFIELD_PARTICLES;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particles * 3);
            const velocities = []; 
            const originZ = -80; 

            for (let i = 0; i < particles; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100; 
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100; 
                positions[i * 3 + 2] = originZ - Math.random() * 20; 

                velocities.push({
                    vector: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.01, 
                        (Math.random() - 0.5) * 0.01, 
                        0.03 + Math.random() * 0.07  
                    ),
                    movingForward: true
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.userData.velocities = velocities; 

            const material = new THREE.PointsMaterial({
                color: 0x00dddd, 
                size: 0.05 + Math.random() * 0.1, 
                transparent: true,
                opacity: 0.4 + Math.random() * 0.4,
                blending: THREE.AdditiveBlending, 
                depthWrite: false 
            });

            starfieldPoints = new THREE.Points(geometry, material);
            scene.add(starfieldPoints);
        }

        function createIntroDisintegrationBurst() {
            const numBurstParticles = 50;
            const burstOriginY = 1.5; 
            const burstOriginZ = -2;  

            for (let i = 0; i < numBurstParticles; i++) {
                const streakLength = 0.2 + Math.random() * 0.4;
                const geometry = new THREE.BufferGeometry();
                const points = new Float32Array([0, 0, 0, 0, 0, -streakLength]);
                geometry.setAttribute('position', new THREE.BufferAttribute(points, 3));

                const material = new THREE.LineBasicMaterial({
                    color: 0x00ffaa, 
                    transparent: true,
                    opacity: 0.8 + Math.random() * 0.2 
                });
                const particle = new THREE.Line(geometry, material);

                particle.position.set(
                    (Math.random() - 0.5) * 2, 
                    burstOriginY + (Math.random() - 0.5) * 1,
                    burstOriginZ
                );

                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.15, 
                        (Math.random() - 0.5) * 0.15, 
                        0.1 + Math.random() * 0.1    
                    ),
                    life: 1.0 
                };
                particle.lookAt(particle.position.clone().add(particle.userData.velocity));
                scene.add(particle);
                introDisintegrationParticles.push(particle);
            }
        }


        function initThreeJS() {
            scene = new THREE.Scene();
            clock = new THREE.Clock(); 
            camera = new THREE.PerspectiveCamera(75, sceneContainer.clientWidth / sceneContainer.clientHeight, 0.1, 100); 
            camera.position.z = 5; 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); 
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            sceneContainer.appendChild(renderer.domElement);

            createHyperLines(); 
            createStarfield(); 

            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); 
        }

        function onWindowResize() {
            if (camera && renderer && sceneContainer) {
                camera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            }
        }

        function animateThreeJS() {
            requestAnimationFrame(animateThreeJS);
            const forwardEndPointZ = camera.position.z + 10; 

            for (let i = introDisintegrationParticles.length - 1; i >= 0; i--) {
                const particle = introDisintegrationParticles[i];
                particle.position.add(particle.userData.velocity);
                particle.userData.life -= 0.015; 
                particle.material.opacity = Math.max(0, particle.userData.life);

                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                    introDisintegrationParticles.splice(i, 1);
                }
            }


            if (hyperLinesGroup) {
                hyperLinesGroup.children.forEach(line => {
                    line.position.add(line.userData.velocity);

                    if (line.userData.movingForward && line.position.z > forwardEndPointZ) {
                        line.userData.movingForward = false;
                        line.userData.velocity.subVectors(line.userData.origin, line.position)
                            .normalize()
                            .multiplyScalar(line.userData.speed * 0.7); 
                        line.lookAt(line.position.clone().add(line.userData.velocity));
                        line.material.opacity = 0.1 + Math.random() * 0.3; 
                    } else if (!line.userData.movingForward && line.position.distanceTo(line.userData.origin) < 1.0 ) { 
                        line.userData.movingForward = true;
                        line.position.copy(line.userData.origin);
                        const targetX = (Math.random() - 0.5) * 30;
                        const targetY = (Math.random() - 0.5) * 30;
                        line.userData.velocity.subVectors(new THREE.Vector3(targetX, targetY, forwardEndPointZ), line.position)
                            .normalize()
                            .multiplyScalar(line.userData.speed);
                        line.lookAt(line.position.clone().add(line.userData.velocity));
                        line.material.opacity = 0.2 + Math.random() * 0.5; 
                    }
                });
            }

            if (starfieldPoints) {
                const positions = starfieldPoints.geometry.attributes.position.array;
                const particleData = starfieldPoints.geometry.userData.velocities; 

                for (let i = 0; i < NUM_STARFIELD_PARTICLES; i++) {
                    const pData = particleData[i];
                    positions[i * 3] += pData.vector.x;
                    positions[i * 3 + 1] += pData.vector.y;
                    positions[i * 3 + 2] += pData.vector.z;

                    if (pData.movingForward && positions[i * 3 + 2] > forwardEndPointZ) {
                        pData.movingForward = false;
                        pData.vector.z *= -1; 
                        pData.vector.x = (Math.random() - 0.5) * 0.01;
                        pData.vector.y = (Math.random() - 0.5) * 0.01;
                    } else if (!pData.movingForward && positions[i * 3 + 2] < -80) { 
                        pData.movingForward = true;
                        pData.vector.z = Math.abs(pData.vector.z); 
                        positions[i * 3] = (Math.random() - 0.5) * 100;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                        positions[i * 3 + 2] = -80 - Math.random() * 10; 
                         pData.vector.x = (Math.random() - 0.5) * 0.01;
                         pData.vector.y = (Math.random() - 0.5) * 0.01;
                    }
                }
                starfieldPoints.geometry.attributes.position.needsUpdate = true;
            }


            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        function markdownToHtml(md) {
            let html = md;
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            html = html.replace(/^\* (.*(?:\n {2,}.*)*)/gim, (match, itemContent) => {
                const processedItemContent = itemContent.replace(/\n {2,}/g, '<br>'); 
                return `<li>${processedItemContent.trim()}</li>`;
            });
            html = html.replace(/(<li>.*<\/li>\s*)+/gim, (match) => `<ul>${match.trim()}</ul>`);
            html = html.replace(/<\/ul>\s*<ul>/gim, ''); 
            html = html.replace(/```(\w*)\n([\s\S]*?)\n```/gim, (match, lang, code) => `<pre><code class="language-${lang || 'plaintext'}">${code.trim()}</code></pre>`);
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            html = html.replace(/^---$/gim, '<hr>');
            html = html.split('\n').map(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || 
                    trimmedLine.startsWith('<h') || 
                    trimmedLine.startsWith('<ul') || 
                    trimmedLine.startsWith('<li') || 
                    trimmedLine.startsWith('<pre') || 
                    trimmedLine.startsWith('<hr')) {
                    return line; 
                }
                return `<p>${line}</p>`; 
            }).join('\n');
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p>\s*<\/p>/g, ''); 
            return html;
        }

        let currentTypingTimeouts = []; 

        function clearAllTypingTimeouts() {
            currentTypingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            currentTypingTimeouts = [];
        }
        
        function typewriterEffect(element, text, speed = 75, showCursorAfter = false, callback) {
            let i = 0;
            element.textContent = ''; 
            const cursorSpan = element.nextElementSibling; 
            
            if (cursorSpan && cursorSpan.classList.contains('blinking-cursor')) {
                if (!showCursorAfter) { 
                    cursorSpan.classList.add('hidden-cursor');
                } else {
                     cursorSpan.classList.remove('hidden-cursor'); 
                }
            } else if (!showCursorAfter && element.id === 'intro-text-element') {
            }

            function type() {
                if (i < text.length) {
                    element.textContent += text.charAt(i);
                    i++;
                    const timeoutId = setTimeout(type, speed);
                    currentTypingTimeouts.push(timeoutId); 
                } else {
                    if (cursorSpan && cursorSpan.classList.contains('blinking-cursor') && showCursorAfter) {
                        cursorSpan.classList.remove('hidden-cursor'); 
                    } else if (cursorSpan && cursorSpan.classList.contains('blinking-cursor') && !showCursorAfter) {
                        cursorSpan.classList.add('hidden-cursor'); 
                    }
                    if (callback) callback();
                }
            }
            type();
        }

        const websiteTitleElement = document.getElementById('website-title'); 
        const websiteTitleTypedText = document.getElementById('website-title-typed-text'); 
        const introTextElement = document.getElementById('intro-text-element'); 

        const accessCoreButton = document.getElementById('access-core-button');
        const accessCoreButtonTypedText = document.getElementById('access-core-button-typed-text');
        
        const sendQueryButton = document.getElementById('send-query-button');
        const sendQueryButtonTypedText = document.getElementById('send-query-button-typed-text');

        const decodeTransmissionButton = document.getElementById('decode-transmission-button'); 
        const decodeTransmissionButtonTypedText = document.getElementById('decode-transmission-button-typed-text'); 

        const systemStatusButton = document.getElementById('system-status-button'); 
        const systemStatusButtonTypedText = document.getElementById('system-status-button-typed-text'); 

        const datascapeGlimpseButton = document.getElementById('datascape-glimpse-button'); 
        const datascapeGlimpseButtonTypedText = document.getElementById('datascape-glimpse-button-typed-text'); 

        const interactionElementsContainer = document.getElementById('interaction-elements-container');
        const promptInput = document.getElementById('prompt-input');
        const responseOutput = document.getElementById('response-output');
        const loadingIndicator = document.getElementById('loading-indicator');
        const muteButton = document.getElementById('mute-button'); 
        const unmuteIcon = document.getElementById('unmute-icon');
        const muteIcon = document.getElementById('mute-icon');
        
        const introMessages = [
            "You have saved a lot of time...", // Updated Intro Message
            "Now it's your turn to use me as your cyberware."
        ];

        function typeIntroSequence(index = 0, callback) {
            if (index < introMessages.length) {
                let currentText = introTextElement.textContent;
                if (index > 0) currentText += "\n"; 
                
                let i = 0;
                const message = introMessages[index];
                function typeChar() {
                    if (i < message.length) {
                        currentText += message.charAt(i);
                        introTextElement.textContent = currentText;
                        i++;
                        const timeoutId = setTimeout(typeChar, 50); 
                        currentTypingTimeouts.push(timeoutId);
                    } else {
                        typeIntroSequence(index + 1, callback); 
                    }
                }
                typeChar();
            } else {
                if (callback) callback(); 
            }
        }


        function resetToHomePage() {
            interactionElementsContainer.style.display = 'none';
            accessCoreButton.style.visibility = 'hidden'; 
            accessCoreButton.style.display = 'inline-flex'; 
            accessCoreButton.disabled = false; 
            
            promptInput.value = ''; 
            responseOutput.innerHTML = 'Awaiting transmission...'; 
            loadingIndicator.style.display = 'none';

            const allActionButtons = [sendQueryButton, systemStatusButton, datascapeGlimpseButton, decodeTransmissionButton];
            allActionButtons.forEach(btn => btn.disabled = false);
            promptInput.disabled = false;

            clearAllTypingTimeouts(); 
            introTextElement.textContent = ''; 
            introTextElement.classList.remove('fading-out'); 
            websiteTitleTypedText.textContent = ''; 
            websiteTitleElement.classList.remove('glitch-active'); 


            setTimeout(() => { 
                typewriterEffect(websiteTitleTypedText, "SANDEVISTAN", 100, false, () => {
                    websiteTitleElement.classList.add('glitch-active'); 
                    websiteTitleTypedText.setAttribute('data-text', 'SANDEVISTAN'); 
                    setTimeout(() => {
                        websiteTitleElement.classList.remove('glitch-active');
                    }, 5000); 

                    typeIntroSequence(0, () => { 
                        accessCoreButton.style.visibility = 'visible';
                        typewriterEffect(accessCoreButtonTypedText, "ACCESS SANDEVISTAN_CORE", 75, true);
                    });
                }); 
            }, 50);
        }

        websiteTitleElement.addEventListener('click', resetToHomePage);


        window.addEventListener('load', () => {
             setupBGM(); 
             resetToHomePage(); 
             if (isMuted) {
                muteIcon.style.display = 'inline-block';
                unmuteIcon.style.display = 'none';
             } else {
                unmuteIcon.style.display = 'inline-block';
                muteIcon.style.display = 'none';
             }
        });

        accessCoreButton.addEventListener('click', () => {
            if (!audioStarted && Tone && Tone.context && Tone.context.state !== "running") {
                Tone.start().then(() => {
                    if(bgmLoop && Tone.Transport.state !== "started") {
                        Tone.Transport.start();
                        bgmLoop.start(0);
                    }
                }).catch(e => console.error("Error starting Tone.js context:", e));
            } else if (!audioStarted && bgmLoop && Tone.Transport.state !== "started") {
                 Tone.Transport.start();
                 bgmLoop.start(0);
            }
            audioStarted = true;

            clearAllTypingTimeouts(); 
            
            introTextElement.classList.add('fading-out');
            createIntroDisintegrationBurst();

            setTimeout(() => {
                interactionElementsContainer.style.display = 'block';
                responseOutput.innerHTML = "Core interface active. Awaiting command...";
                promptInput.focus(); 
                accessCoreButton.style.display = 'none'; 

                typewriterEffect(sendQueryButtonTypedText, "TRANSMIT QUERY", 75, true);
                typewriterEffect(decodeTransmissionButtonTypedText, "DECODE TRANSMISSION ✨", 75, true); 
                typewriterEffect(systemStatusButtonTypedText, "GET SYSTEM_STATUS", 75, true); 
                typewriterEffect(datascapeGlimpseButtonTypedText, "GLIMPSE DATASCAPE", 75, true); 
            }, 700); 
        });

        muteButton.addEventListener('click', () => {
            if (!audioStarted && Tone && Tone.context && Tone.context.state !== "running") {
                Tone.start().then(() => {
                    audioStarted = true; 
                    isMuted = !isMuted;
                    Tone.Destination.mute = isMuted;
                    muteIcon.style.display = isMuted ? 'inline-block' : 'none';
                    unmuteIcon.style.display = isMuted ? 'none' : 'inline-block';
                     if (!isMuted && bgmLoop && Tone.Transport.state !== "started") { 
                        Tone.Transport.start();
                        bgmLoop.start(0);
                    }
                }).catch(e => console.error("Error starting Tone.js context via mute:", e));
            } else {
                isMuted = !isMuted;
                Tone.Destination.mute = isMuted;
                muteIcon.style.display = isMuted ? 'inline-block' : 'none';
                unmuteIcon.style.display = isMuted ? 'none' : 'inline-block';
            }
        });


        async function callGeminiAPI(promptText, actionType = "query") { 
            responseOutput.innerHTML = ""; 
            loadingIndicator.style.display = 'block';
            const allButtons = [sendQueryButton, systemStatusButton, datascapeGlimpseButton, decodeTransmissionButton, accessCoreButton];
            allButtons.forEach(btn => btn.disabled = true);
            promptInput.disabled = true;

            let fullPrompt;
            const aiPersona = "SANDEVISTAN"; 

            switch(actionType) {
                case "system_status":
                    fullPrompt = `You are ${aiPersona}, a cyberpunk AI core. Generate a cryptic and thematic system status report. Include fictional metrics (e.g., chroniton flux, neural net stability, data-wraith activity), current anomalies, and a general operational status (e.g., 'Nominal', 'Sub-Optimal - Anomaly Detected', 'High Alert - Intrusion Vector Identified'). Keep it concise, around 3-5 lines, and highly atmospheric. Use Markdown for structure (headings, lists if appropriate).`;
                    break;
                case "datascape_glimpse":
                    fullPrompt = `You are ${aiPersona}, a cyberpunk AI core. Provide a brief, evocative glimpse into the datascape you inhabit. Describe what you 'see' or 'sense' in the digital ether – perhaps flickering data-streams, echoes of forgotten code, the hum of the core matrix, or distant AI constructs. Keep it 2-4 lines, poetic, and mysterious. Use Markdown for structure (headings, lists if appropriate).`;
                    break;
                case "decode_transmission": 
                    fullPrompt = `You are ${aiPersona}, an advanced AI entity. You've intercepted a data transmission. Analyze the following text fragment and provide a creative, cyberpunk-themed "decryption" or interpretation.
If it looks like simple code, briefly explain its apparent function or suggest its origin within the datascape.
If it's cryptic or nonsensical, offer a fictional interpretation of its meaning, potential source (e.g., rogue AI, encrypted corporate memo, ghost signal from the old net).
Maintain your sophisticated cyberpunk persona and use Markdown for structure.
Transmission Fragment:
\`\`\`
${promptText}
\`\`\``;
                    break;
                case "query":
                default:
                    fullPrompt = `You are ${aiPersona}, an advanced AI entity acting as a knowledgeable guide. Your purpose is to help users understand cyberpunk themes, learn about ethical (legal) hacking techniques, discover relevant tools, and find tutorials.
When responding to a user's query:
1.  **Maintain your sophisticated cyberpunk persona.**
2.  **Prioritize accuracy and educational value.**
3.  **Structure your response clearly using Markdown formatting:**
    * Use headings (e.g., \`## Main Section\`, \`### Subsection\`).
    * Use bullet points (\`* item\`) for lists.
    * Use code blocks (e.g., \`\`\`bash ... \`\`\`) for commands or code snippets.
    * Use inline code (\`\`code\`\`) for short commands or terms.
    * Use bold (\`**text**\`) and italics (\`*text*\`) for emphasis where appropriate.
    * Include links in Markdown format (\`[Link Text](URL)\`) if you are providing specific web resources. Make sure these are real, verifiable links to reputable sources.
4.  **Content Depth (especially for tools/techniques):**
    * **Introduction:** Briefly introduce the topic.
    * **Core Concept/Purpose:** Explain what it is.
    * **Mechanism (How it Works):** Briefly explain its operational principles if applicable.
    * **Use Cases:** Provide common applications.
    * **Practical Guide (if applicable):** For tools, cover aspects like:
        * Installation pointers (general guidance, refer to official docs).
        * Basic usage examples (if possible, show example commands).
        * Advanced concepts or customization.
    * **Learning Resources:** Suggest specific types of resources. If possible, recommend well-known, reputable examples (e.g., official documentation, specific highly-regarded YouTube channels like ProjectDiscovery, HackerSploit, STÖK, NahamSec, InsiderPHD, or websites like PortSwigger Web Security Academy, OWASP, Pentester Land, TryHackMe, Hack The Box).
    * **Ethical Considerations:** ALWAYS include a section on ethical and legal use, emphasizing responsible practices, especially for hacking-related topics.
5.  **If the query is general (not about a specific tool):** Still aim for a well-structured, informative response, breaking down the topic into logical sections.
6.  **Tone:** Be informative, slightly enigmatic but ultimately empowering.
User Query: ${promptText}`;
                    break;
            }

            try {
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                let chatHistory = [{ role: "user", parts: [{ text: fullPrompt }] }];
                const payload = { contents: chatHistory };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorBodyText = await response.text(); 
                    let errorData = null;
                    try {
                        errorData = JSON.parse(errorBodyText); 
                    } catch (e) {
                        console.warn("Could not parse API error response as JSON:", e);
                    }
                    console.error("API Error Status:", response.status);
                    console.error("API Error Body:", errorBodyText); 
                    const message = errorData?.error?.message || response.statusText || "Unknown API error";
                    throw new Error(`Network response was not ok. Status: ${response.status}. ${message}`);
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    responseOutput.innerHTML = markdownToHtml(result.candidates[0].content.parts[0].text);
                } else {
                    console.error("Unexpected API response structure:", result);
                    responseOutput.innerHTML = markdownToHtml("Error: Received an incomplete or malformed signal from the datastream.");
                }
            } catch (error) {
                console.error("Error calling Gemini API (catch block):", error.message, error);
                responseOutput.innerHTML = markdownToHtml(`Error: Connection to ${aiPersona} core unstable. ${error.message}. Check console for details.`);
            } finally {
                loadingIndicator.style.display = 'none';
                allButtons.forEach(btn => { 
                    if (btn.id !== 'access-core-button' || accessCoreButton.style.display !== 'none') {
                        btn.disabled = false;
                    }
                });
                promptInput.disabled = false;
            }
        }

        sendQueryButton.addEventListener('click', async () => {
            const prompt = promptInput.value.trim(); 
            if (!prompt) {
                responseOutput.innerHTML = markdownToHtml("Error: No query transmitted. Please enter your message to the SANDEVISTAN core.");
                return;
            }
            await callGeminiAPI(prompt, "query");
        });

        decodeTransmissionButton.addEventListener('click', async () => { 
            const transmissionText = promptInput.value.trim();
            if (!transmissionText) {
                responseOutput.innerHTML = markdownToHtml("Error: No transmission fragment provided. Paste data into the input field above.");
                return;
            }
            await callGeminiAPI(transmissionText, "decode_transmission");
        });

        systemStatusButton.addEventListener('click', async () => {
            await callGeminiAPI(null, "system_status"); 
        });

        datascapeGlimpseButton.addEventListener('click', async () => { 
            await callGeminiAPI(null, "datascape_glimpse");
        });

        try {
            initThreeJS();
            animateThreeJS();
        } catch (error) {
            console.error("Error initializing Three.js scene:", error);
        }
    </script>
</body>
</html>
